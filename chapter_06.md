- 最も広く使われるリファクタリングは、コードから関数を抽出すること（「関数の抽出」）と、変数を抽出すること（「変数の抽出」）。これらの逆リファクタリングもよく使う（「関数のインライン化」や「変数のインライン化」）。

## 関数の抽出
逆：関数のインライン化（p.121）

### 動機
- 意図と実装を分離するために行う。関数の目的を関数名として抽出することで、中身の実装を見ずに済む。
- 命名には細心の注意を払う。
- コードコメントが関数名のヒントを与えてくれることもある。

### 手順
1.新たな関数を作り、その意図に沿って命名する（どうやるかではなく、何をするかによって名付ける）。
　可能なら、抽出した関数を元の関数に入れ子にする。
2.抽出したいコードを、元の関数から新たな関数にコピーする。
3.抽出したコードを調べて、元の関数ではスコープ内だったが抽出後の関数ではスコープ外になった変数を特定する。それらをパラメータとして渡す。
4.全ての変数を処置したらコンパイルする。
5.元の関数に残った抽出前のコードを、抽出された関数への呼び出しに置き換える。
6.テストする。
7.残りのコードを見て、抽出したコードと同じ又は類似したコードを探し、「関数呼び出しによるインラインコードの置き換え」を適用し、新しい関数を呼ぶ形にできないか検討する。

- 戻り値用の変数が複数個必要な時は、たいてい一時変数に手を加える。
- 「問い合わせによる一時変数の置き換え」や「変数の分離」を使う。

## 関数のインライン化
逆：関数の抽出（p.112）

### 動機
- 関数の本体がその名前と同等にわかりやすい時は、関数を取り除く。不要な間接化を避ける。
- うまく分割できていない関数群があるときにも使う。

### 手順
1.関数がポリモーフィックなメソッドでないことを確認する。
2.この関数の呼び出し元を全て見つける。
3.関数の各呼び出し元を関数の中身で置き換える。
4.一つ置き換えるごとにテストする。
5.関数の定義を取り除く。

## 変数の抽出
逆：変数のインライン化（p.129）

### 動機
- 式が複雑で読みにくくなるとき、ローカル変数を活用して式を分解することで扱いやすくする。
- ロジックの式の一部に名前をつけられるので、意図がわかりやすくなる。
「変数の抽出」を検討するのは、コード内の式に名前をつけたいとき。

### 手順
1.抽出しようとする式に副作用がないことを確認する。
2.変更不可な変数を定義する。名付けたい式の値をその変数に設定する。
3.元の式を新しい変数で置き換える。
4.テストする。

## 変数のインライン化
逆：変数の抽出（p.125）

### 動機
- 変数名が式以上の情報を持たない場合。あるいは、変数が周辺コードのリファクタリングの邪魔になる場合。

### 手順
1.代入の右辺に副作用がないことを確認する。
2.その変数が変更不可と宣言されていなければ、変更不可にしてテストする。
3.その変数への最初の参照を探し、代入の右辺と置き換える。
4.テストする。
5.変数を参照している箇所の置き換えを繰り返し、全ての参照箇所を更新する。
6.変数の宣言と代入を取り除く。
7.テストする。

## 関数宣言の変更

### 動機
- 関数宣言はソフトウェアシステムにおける継ぎ目。継ぎ目の要素で最も重要なのは関数名。
- 間違った名前の関数は混乱の元なので、見つけたら良い名前がわかり次第変更する。（名前を改善する良い方法は、関数の目的をコメントとして書き、それを名前に変えること。）
- 同じ理屈がパラメータにも当てはまる。パラメータは関数を使う場合の文脈を設定するので、適切なものを設定すれば、より広い範囲で活用できる関数になる。
- そうすると、関数の適用範囲を広げることができ、ひいては（モジュール間などの）結合を取り除くこともできる。（モジュールが互いに知らなければならないことを減らせる。）
- 大切なのは、「関数宣言の変更」に慣れ親しんで起き、最善のコードの継ぎ目がわかるにつれてコードを進化させられるようにしておくこと。

### 手順
#### 簡易な手順
1.パラメータを削除する場合、それが関数内部で参照されていないことを確認する。
2.関数宣言を望ましいものに変更する。
3.古い関数宣言への全ての参照を探し、新しいものに更新する。
4.テストする。

#### 移行的手順
1.必要なら関数の本体をリファクタリングして、以降の抽出のステップを実施しやすくしておく。
2.関数本体に「関数の抽出（p.112）」を施して、新たな関数を作る。
3.抽出した関数が追加のパラメータを必要とする場合、簡易な手順により追加を行う。
4.テストする。
5.古い関数に「関数のインライン化（p.121）」を施す。
6.一時的な名前を使った場合、「関数宣言の変更」を再び施し、元の名前に戻す。
7.テストする。

## 変数のカプセル化

### 動機
- 関数は、古い関数を転送よう関数として残し、関数に新たな名前をつけたり移動したりすることが簡単にできる。一方、データはこうしたことができず、扱いづらい。そのため、広い範囲で利用されるデータを移動したいときは、まずそれをカプセル化して、変数へのアクセスを関数経由にするのが非常に良いやり方である。データのカプセル化は、データの変更や参照を監視できるという利点もある。
- レガシーコードに対処するときは、変数への参照を変更したり追加したりする機会を見つけては、変数をカプセル化すること。
- 変更不可のデータについては、カプセル化はそれほど重要ではない。

### 手順
1.変数を参照・更新するためのカプセル化用関数を作る。
2.静的チェックを実行する。
3.変数への参照を、一つひとつ適切なカプセル化関数の呼び出しに置き換える。置き換えるごとにテストする。
4.変数の可視性を制限する。
5.テストする。
6.変数の値がレコードの場合、「レコードのカプセル化（p.168）」を検討する。

## 変数名の変更
```
let a = height * width
↓
let area = height * width
```

### 動機
- 変数はうまく名付ければ、目的を説明する上で非常に役立つ。
- 変数名の重要性は、どれくらい広い範囲で使われるかに影響を受ける。
- １回の関数の呼び出しを超えて存続する永続的なフィールドについては、より注意深く名前をつける必要がある。

### 手順
1.変数が広く使われている場合、「変数のカプセルか（p.138）」を検討する。
2.変数への参照をくまなく探し、それらを全て変更する。
3.テストする。

## パラメータオブジェクトの導入
```
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}

↓
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

### 動機
- ひとまとまりのデータ項目を、単一のデータ構造に置き換えたくなる。
- データを構造体にすることで、データ項目間の関係を明示できる。
- 新たな構造体を使うようにプログラムの振る舞いを改める過程で、
- コードの概念的な構図が変化し、問題領域の理解がすっきりしてくる。

### 手順
1.ふさわしい構造体がまだ存在しないなら、作成する。
2.テストする。
3.「関数宣言の変更（p.130）」を施し、新たな構造体用のパラメータを追加する。
4.テストする。
5.新たな構造体の正しいインスタンスを渡すように各呼び出し側を修正する。一つの呼び出しを修正するごとにテストする。
6.元のパラメータを使用している箇所を、新たな構造体の要素を使うように一つ一つ置き換える。元のパラメータを削除し、テストする。

- 新たな構造体（多くの場合クラス）を作ることの大きな利点は、振る舞いを写すことができるということである。

## 関数群のクラスへの集約
```
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}

↓
class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseCharge() {...}
}
```

### 動機
- 共通のデータに対して互いに関わりの深い処理を行う一群の関数があれば、クラスを使うチャンスである。クラスを使うことで、これらの関数が共有する環境がより明示的になり、関数の引数が大幅に減ることで、オブジェクト内の関数呼び出しを単純化できる。
- 関数を体系化するもう一つ別の方法として「関数群の変換への集約（p.155）」があり、どちらを使うかは、プログラムのより大きな文脈で決まる。

### 手順
1.関数間で共有しているデータのレコードに「レコードのカプセル化（p.168）」を施す。
2.「関数の移動（p.206）」を適用して、共通レコードを扱う関数をそれぞれ、新たなクラスへと移す。
3.データを操作するロジックの断片があればそれぞれ、「関数の抽出（p.112）」で抽出してクラスに移す。

## 関数群の変換への集約
```
function base(aReading) {...}
function taxableCharge(aReading) {...}

↓
function enrighReading(argReading) {
  const aReading = _.cloneDeep(argReading);
  aReading.baseCharge = base(aReading);
  aReading.taxableCharge = taxableCharge(aReading);
  return aReading;
}
```

### 動機
- プログラムに投入したデータの派生値は、まとめた方が望ましい。
- その一つの方法はデータ変換関数を使うことである。これは元データを入力として全ての派生値を計算し、それらを出力データのフィールドとして設定するもの。
- 「関数群のクラスへの集約」との違いは、元データがコード内で更新される場合は、クラスを使う方が良いということ。

### 手順
1.変換されるレコードを入力とし、同じ値を返す変換関数を作る。
2.ロジックを選んでその本体を変換関数側に移し、レコードに新たなフィールドを設ける。そのフィールドを使うようにクライアント側のコードを変更する
3.テストする。
4.その他の関連した関数群について上記の手順を繰り返す。

## フェーズの分離
```
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;

↓
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString) {
  const values = aString.split(/\s+/);
  return ({
    productID: values[0].split("-")[1],
    quantity: parseInt(values[1]),
  });
}
function price(order, priceList) {
  return order.quantity * priceList[order.productID];
}
```

### 動機
- 一つのコードが異なる二つの処理を行っている場合、別々のモジュールに分離する方法がないかを探す。
- そうした分離に力を割くのは、変更が必要になった時に、トピックごとに分けて対処することができるためである。
- 綺麗な分離を行うために、振る舞いを順次的な2段階のフェーズに分けるのが良い。
- 処理を始める前に、入力をメインの処理に都合の良い形式に整形する。

### 手順
1.後半となるフェーズのコードを、関数として抽出する。
2.テストする。
3.抽出した関数に追加される引数として、中間データ構造を導入する。
4.テストする。
5.抽出した後半のフェーズの各パラメータを確認する。それらが前半のフェーズでも使われているなら、中間データ構造へと移す。一つ移すごとにテストする。
6.前半のフェーズのコードに「関数の抽出（p.112）」を施し、中間データ構造を返すようにする。
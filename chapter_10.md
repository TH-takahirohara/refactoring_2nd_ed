# 第10章 条件記述の単純化
- プログラムの複雑さの多くは条件記述に起因する。
    - 複雑な条件記述に対しては「条件記述の分解」を行い、論理の組み合わせを明解にするために「条件記述の結合」を行う。
    - 主処理の前に幾つかの事前判定を行うケースを明確にするためには、「ガード節による入れ子の条件記述の置き換え」を行う。
    - 複数の条件記述で同じ条件分岐ロジックを使っている場合は、「ポリモーフィズムによる条件記述の置き換え」を行う。
    - nullのような特殊ケースを処理するためのロジックがほとんど同じ場合は、「特殊ケースの導入」を適用する。
    - 多くの条件記述を削除する際に、プログラムの状態を把握した場合は、「アサーションの導入」が有用である。

## 条件記述の分解

### 動機

- 大きなブロックのコードに対しては常に、コードを分解し、それぞれを意図に沿って名付けた関数の呼び出しに置き換えることで、意図をより明確にできる。
- 条件記述の場合、条件判定と条件毎の処理に対してこれを行うことで、条件を強調し、何を分岐させているのかを明確にする。また分岐の理由も強調する。
- 「関数の抽出」の特殊ケースと言える。

### 手順

- 条件記述および条件の各節に「関数の抽出」を適用する。

## 条件記述の統合

### 動機

- 一連の条件判定があって、それぞれの条件は異なるが、結果のアクションが同じ場合がある。そうした時は、andやor演算子を使って、単一の結果を返す一つの条件判定に統合する。
- 上記を行う重要な理由は二つある。一つ目の理由は、まとめることで、行っている判定が実は一つだという意図を明示できること。二つ目の理由は、「関数の抽出」の準備になる場合が多いこと。そのステートメントが何をやっているのかから、なぜやっているのかに置き換えることができる。
- もし複数の判定が本当に別々のもので、単一の判定と考えるべきでないなら、このリファクタリングは行わない。

### 手順

- いずれの条件判定にも副作用がないことを確認する。
    - いずれかに副作用がある場合は、最初に「問い合わせと更新の分離」を行う。
- 条件判定を二つ取り出し、論理演算子を使って結合する。
- テストする。
- 条件が一つになるまで、条件判定の結合を繰り返す。
- 結果として得られた条件判定に対して「関数の抽出」を検討する。

## ガード節による入れ子の条件記述の置き換え

### 動機

- 条件記述には二つのスタイルがあると考えられる。一つ目は、then節とelse節の両方が正常動作の場合で、二つ目は、どちらか一方の節が正常動作で他方が例外的な動作の場合。
- この２種類の条件記述は意図が異なるため、その違いをコードにきちんと表現すべきである。
- 例外的な動作に対しては、その条件を判定し、成立する場合にはリターンする。この種の判定をよくガード節と呼ぶ。
- 重要な点は強調の仕方にある。著者がif-then-else構文を使うときは、then節にもelse節にも同じウェイトを置き、両方が等しく重要であることを伝える。逆に、ガード節は「主要な処理ではないため、起きたときには何がしかのことをやって脱出する」ことを伝える。

### 手順

- 置き換えるべき条件で最も外側のものを選択し、ガード節に変更する。
- テストする。
- 必要に応じて繰り返す。
- すべてのガード節が同じ結果を返す場合は、「条件記述の統合（第10章）」を行う。

## ポリモーフィズムによる条件記述の置き換え

### 動機

- クラスとポリモーフィズムを用いて、複雑な条件ロジックに構造を与えて分離すると分かりやすくなる場合がある。
- よくある状況として、switch文を含む関数が複数存在する場合、各ケースに対応するクラスを作成し、ポリモーフィズムを利用することで、ロジックの重複を排除する。
- もう一つの状況は、ロジックがバリエーションを持つ基本ケースとみなせる場合。基本ケースのロジックをスーパークラスに記述することで、バリエーションについて気にせずに、ロジックを把握できる ようになる。各バリエーションのロジックをサブクラスに記述すれば、基本ケースとの違いを強調したコードが記述できる。
- ポリモーフィズムは多用すべきとは言えないが、複雑な条件ロジックを改善する際は強力なツールとなる。

### 手順

- ポリモーフィックな振る舞いを持たせるクラスが存在しない場合は、そのクラスと一緒に適 切なインスタンスを返すファクトリ関数を作成する。
- 呼び出し側のコードで、ファクトリ関数を使うようにする。
- 条件ロジックを持つ関数をスーパークラスに移動する。
    - 条 件 ロ ジ ッ ク が 自 己 完 結 型 の 独 立 し た 関 数 に な っ て い な い 場 合 は 、「 関 数 の 抽 出 ( p . 1 1 2 )」に よって関数にする。
- サブクラスの一つを選んで、条件別のメソッドをオーバーライドするメソッドを作成する。条 件文の該当する節の内容をサブクラスのメソッドにコピーし、適合するように調整する。
- 条件ロジックの各節に対してこれを繰り返す。
- スーパークラスのメソッドにはデフォルトケースを残す。スーパークラスを抽象クラスにすべ き場合は、メソッドの処理がサブクラスの責務であること示すために、そのメソッドを抽象 メソッドとして宣言するか、メソッド内でエラーを投げる。

## 特殊ケースの導入

### 動機

- コード重複のよくあるケースとして、多くのプログラムが、データ構造が特定の値かどうかを判定し、該当する場合には同じ処理をしていることがある。特定の値に対して同じ処理をす るコードがたくさんあると、その処理を 1 か所にまとめたくなる。
- これに対処するための優れた仕組みとして「スペシャルケース」パターンという、特殊ケースとして共通な振る舞いをすべて備えた要素を作成するパターンがある。

### 手順
前提として、リファクタリングの対象となる、プロパティを保持するデータ構造(またはクラス )があるとする。クライアントコードでは、リファクタリング対象となるデータ構造のプロ パティを、特殊ケースの値と比較している。この特殊ケースの値を、特殊ケース用のクラスま たはデータ構造に置き換える。

- 特殊ケースを判定するプロパティをオブジェクトに追加して、false を返すようにする。
- 特殊ケースを判定するプロパティだけを持つ特殊ケース用クラスを作成して、true を返すようにする。
- 特殊ケースと比較するコードに対して「関数の抽出(p.112)」を行う。すべてのクライアントコードで直接比較するのをやめて、この新しい関数を使うようにする。
- 新しく作成した特殊ケース用クラスをコードに導入する。特殊ケース用オブジェクトは関数 呼び出しから返すか、変換関数でオブジェクトに組み込む。
- 特殊ケースと比較する関数の本体を変更して、特殊ケースの判定用プロパティを使うように する。
- テストする。
- 「 関数群のクラスへの集約(p.150)」または「関数群の変換への集約(p.155)」を行って、共通な特殊ケースの処理を特殊ケース用クラスにすべて移動させる。
- 特殊ケース用クラスは通常、単純な問い合わせに対して固定値を返すだけなので、オブジェ クトリテラルで対応できる場合もある。
- 依然として特殊ケースの判定が必要な場所については、特殊ケース比較関数の呼び出しロ ジックに対して「関数のインライン化(p.121)」を行う。

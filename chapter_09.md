# 第9章 データの再編成
- データ構造に焦点を当てたリファクタリングに関する章
    - 一つの値を異なる目的で利用すると混乱やバグの温床となるので「変数の分離」を行う
    - 変数を完全に取り除く場合には「問い合わせによる導出変数の置き換え」を行う
    - 参照オブジェクトと値オブジェクトの混乱を解決するために、「参照から値への変更」あるいは「値から参照への変更」を行う

## 変数の分離

### 動機

- 変数に何度も代入することが不可欠な場合（ループ用変数やメソッドで処理した値を一つに集めるための変数（収集用変数））を除き、変数を設定するのは一度だけにすべき
- 何度も設定するという事は、そのメソッドにおいて変数が複数の責務を持っていることを示唆しているので、それぞれの責務を持つ一つの変数で置き換えるべき。

### 手順

- 宣言時と最初の代入時の変数名を変える。
- 可能ならば、新しい変数は変更不可と宣言する。
- 2回目の代入より前にある元の変数への全ての参照を変更する。
- テストする。
- 代入があるごとに宣言箇所で変数の名前を変更し、次の代入までの参照を変更する。最終的な代入に達するまでこれを順次繰り返す。

## フィールド名の変更

### 動機

- 名前は重要である。
- ソフトウェアでの作業をするにつれて理解が深まったら、その理解を反映させたフィールド名に変更することが重要である。

### 手順

- レコードのスコープが限定されている場合は、そのフィールドを使っている箇所のすべての名前を変更してテストする。その場合、残りの手順を行う必要はない。
- レコードがカプセル化されていない場合は、「レコードのカプセル化（第7章）」を行う。
- オブジェクト内の非公開フィールドの名前を変更し、内部メソッドを調整する。
- テストする。
- コンストラクタがその名前を使用する場合は、「関数宣言の変更（第6章）」を行って名前を変更する。
- アクセサに対して「関数名の変更（第6章）」を行う。

## 問い合わせによる導出変数の置き換え

### 動機

- ソフトウェアにおける問題の発生源として大きな割合を占めるのは、変更可能なデータである。変更可能なデータの影響範囲をできる限り小さくすべきというのが著者の主張。
- この問題への非常に有効な対処法の一つは、簡単に計算できる変数をすべて削除することである。

### 手順

- 対象とする変数の更新箇所をすべて特定する。必要に応じて、「変数の分離（第9章）」を行って、それぞれの更新箇所を分離する。
- その変数の値を計算する関数を作る。
- 「アサーションの導入（第10章）」を行って、変数が使用されるたびに、変数と計算結果が同じになることを確認する。
- テストする。
- 変数の参照処理を新たな関数呼び出しで置き換える。
- テストする
- 変数の宣言と更新箇所に対して、「デッドコードの削除（第8章）」を行う。

## 参照から値への変更

### 動機

- オブジェクトやデータ構造を入れ子にする場合、内部オブジェクトは参照または値として扱うことができる。
- あるフィールドを値として扱う場合、内部オブジェクトのクラスは「値オブジェクト」に変更できる。
- 値オブジェクトは、変更不可のため、一般的に仕様の把握が容易で、扱いが簡単である。変更不可のデータ値をプログラムの他の部分に渡しても、保有側のオブジェクトで知らぬ間に値が変更される心配がない。
- 逆に、あるオブジェクトの変更を複数のオブジェクトで共有したい場合、そのオブジェクトは参照のままにしておく必要がある。その場合は、このリファクタリングを適用すべきではない。

### 手順

- 候補のクラスが変更不可になっているか、あるいは変更不可にできるかどうかを確認する。
- 各setterに対して、「setterの削除（第11章）」を行う。
- 値ベースの等価判定メソッドを用意し、値オブジェクトのフィールドを使って判定を行う。

## 値から参照への変更

### 動機

- 複数のレコードが意味的に同じデータ構造にリンクするデータ構造になっている場合、値あるいは参照のどちらでも扱える。
- しかし、値を使って、意味的に同じデータに対して複数の物理コピーを持たせる方法は、共有データを更新する必要があるときに大きな問題になる。すべてのコピーを見つけて漏れなく更新する必要があるためである。
- 通常は、こうした場合、データのコピーを単一の参照に変更することが有用である。値を参照にすることで、一つの実体に対して存在するオブジェクトは唯一になる。
- 通常、こうしたオブジェクトにアクセスできる場所としてなんらかのリポジトリを用意する。実体を一度だけ作成したら、そのあとはリポジトリからオブジェクトを取得できる。

### 手順

- 参照オブジェクトのインスタンス用のリポジトリを作成する（リポジトリが存在しない場合）。
- コンストラクタから参照オブジェクトの適切なインスタンスを検索できるようにする。
- リポジトリを使用して参照オブジェクトを取得するように、コンストラクタを変更する。変更のたびにテストする。

### 注意

- 一つの問題は、コンストラクタ本体がグローバルリポジトリに結合されることである。グローバル情報は慎重に扱わなければならない。心配な場合は、リポジトリをコンストラクタのパラメータとして渡してもよいだろう。

# 第3章 コードの不吉な臭い

本章では、リファクタリングの必要性を示す不吉な兆候について説明する。（正確な基準を示すのは難しく、直感を養うべき領域である。）いつリファクタリングすべきか迷った時のヒントにしてほしい。

## 不可思議な名前
- 明快なコードにするために最も重要なのは、適切な名前付けである。
- しかし、名前付けはプログラミング言語で最も難しい二つのことのうちの一つである。
- そのため、リファクタリングで最も行われる作業であろう。
- 「関数宣言の変更（p.130）」、「変数名の変更（p.143）」、「フィールド名の変更（p.252）」などがこれに該当する。
- 良い名前が思いつかないということは、設計がまだ固まっていないことの兆候でもある。

## 重複したコード
- 同じ構造のコードが2か所以上にある場合、１か所にまとめると良いプログラムになる。

## 長い関数
- 関数が長くなるほど理解しにくくなる。
- 関数が短く分けられている場合、コードを読む開発者にとっては、関数を追っていかねばならず、ある種のオーバーヘッドがかかるという意見があるが、関数名をわかりやすくすれば内部の実装を見なくとも読み進められる。コメントが必要だと感じたら、代わりに分かりやすい名前の関数に分割する。
- 関数を短くするために行う作業の99％は「関数の抽出（p.112）」である。パラメータや一時変数が多すぎる関数は、抽出の妨げとなるので、種々の方法でスリム化する。抽出部分を見つけ出す良い方法は、コメントを探すこと。コメントの意図を関数名として関数を切り出す。条件分岐やループも、抽出の対象になる。

## 長いパラメータリスト

## グローバルなデータ
- グローバルなデータは、今でも遭遇する可能性のある、強烈な臭気の一つ。
- その問題は、コードベースのどこからでも変更できてしまい、どこで変更が行われたかを知るすべもないということにある。最も分かりやすいのはグローバル変数。クラス変数や、Singletonにも見られる。
- このようなデータは、「変数のカプセル化（p.138）」を行うのが良い。

## 変更可能なデータ
- 変更可能なデータは、スコープが広くなるにつれ、危険性が高くなる。

## 変更の偏り
- 「変更の偏り」は、一つのモジュールが異なる目的のために異なる方法で変更される状況である。

## 変更の分散
- 変更を行うたびにあちこちのモジュールが少しずつ書き換わるような場合、不吉な臭いと受け取るべき。

## 特性の横恋慕
- 特性の横恋慕の古典的な例は、あるモジュールの関数が、内部のモジュールよりも、外部のモジュールの関数やデータ構造とやりとりしているというもの。
- 幸い、これを正して行くのは簡単。「関数の移動」を行う。
- ある関数が複数のモジュールのデータを参照している場合、どのモジュールに大部分のデータを持たせるかを決めて、そのモジュールに関数を移動する方法がある。

## データの群れ

## 基本データ型への執着
- 文字列型はよくそのまま使われるが、例えば電話番号など、適切な型を定義してあげれば、一貫した表示用ロジックを持たせることができる。
- 個々のデータに対して、「オブジェクトによるプリミティブの置き換え」を行うのが良い。

## 重複したスイッチ文
- コードの様々な箇所に同じ条件分岐ロジックが書かれていれば、それは「不吉な臭い」。
- これが問題なのは、新たな分岐を追加したら、全ての重複した条件分岐を探して更新しなければならないため。「ポリモーフィズムによる条件記述の置き換え」で対応する。

## ループ
- 「パイプラインによるループの置き換え」で対応可能

## 怠け者の要素
- 不要な要素は、「関数のインライン化（p.121）」や「クラスのインライン化（p.193）」を使って解決する。継承がある場合は、「クラス階層の平坦化（p.387）」を適用する。

## 疑わしき一般化
- 現在は必要としていない凝った仕掛けや特殊な状況を考えているような時には、警戒が必要。
- 大した働きをしていない抽象クラスには、「クラス階層の平坦化（p.387）」を試みると良い。意味のない委譲は、「関数のインライン化（p.121）」や「クラスのインライン化（p.193）」によって削除可能。

## 一時的属性
- インスタンス変数の値が、特定の状況でしか設定されないクラスに出会うことがあるが、このようなコードは理解しづらい。
- 「クラスの抽出（p.189）」を行い、変数の居場所を作るなどする。

## メッセージの連鎖
- クライアントがあるオブジェクトにメッセージを送り、受け取ったオブジェクトがさらに別のオブジェクトにメッセージを送理、それがまた別のオブジェクトへメッセージを送るといった、メッセージの過剰な連鎖が起こることがある。オブジェクトのナビゲーションの過程にクライアントが強く依存することになる。
- こうした時は、「委譲の隠蔽（p.196）」を使うことができる。

## 仲介人
- カプセル化は、しばしば権限の委譲をもたらすが、これが過剰となる場合もある。
- 例えば、メソッドの大半が別のオブジェクトに委譲しているだけのクラスを見ることがある。こうした時には、「仲介人の除去（p.199）」を適用する。

## インサイダー取引
- モジュール間でのデータのやり取りは最小限にとどめ、把握できるようにしておくべきである。
- 相互依存しているモジュールには、「関数の移動（p.206）」や「フィールドの移動（p.215）」を適用する。

## 巨大なクラス
- 一つのクラスがあまりに多くの役割を持っていると、大抵インスタンス変数も多くなり、重複したコードが存在する可能性も高くなる。
- まず、「クラスの抽出（p.189）」を適用して、いくつかの変数をひとまとめにする。
- 一般に、変数の名前に共通の接頭辞や接尾辞が付いている場合には、同一コンポーネントとしてまとめることができるかもしれない。新しくできたコンポーネントが継承でまとまりそうな場合には、「スーパークラスの抽出（p.382）」や「サブクラスによるタイプコードの置き換え（p.369）」の適用が楽。
- 同様に、コード量が多いクラスも重複したコードの温床である。最も単純な解決策は、クラスの冗長部分を排除すること。

## クラスのインタフェース不一致
- 他のクラスへの置き換えが可能になるというクラスの利点は、インタフェースが同じ場合に限る。
- インタフェースを合わせるために、「関数宣言の変更（p.130）」を行う。
- うまくいかない場合は、「関数の移動（p.206）」を適用し、インタフェースが同じになるように振る舞いを適切なクラスに配置するようにする。移動に伴って重複したコードが発生するなら、「スーパークラスの抽出（p.382）」を使う。

## データクラス
- 属性とgetおよびsetメソッド以外に何も持たないクラスには、なるべく早い段階から「レコードのカプセル化（p.168）」を行う。変更されると困る属性には、「setterの削除（p.339）」を行う。
- getまたはsetメソッドが、他のクラスのどこで使われているか調べ、「関数の移動（p.206）」を適用してデータクラスに振る舞いを移せないか考える。関数全体が移せない場合には、「関数の抽出（p.112）」によって、移動できる部分を取り出す。

## 相続拒否
- サブクラスが親の操作のほんの一部しか利用していない場合、継承階層が間違っているというのが伝統的な見方。兄弟となるクラスをあたらに作成して、「メソッドの押し下げ（p.367）」、「フィールドの押し下げ（p.368）」で、使われていないコードを兄弟クラスへと移す。
- ただ、常にこれが勧められるわけではない。上記リファクタリングをせずとも、うまくいくことも多い。継承したものが使われないことで問題が起きている場合にのみ、上記方法を適用すべき。
- サブクラスがスーパークラスの振る舞いは継承するが、インタフェースは必要としないという場合には、臭いはかなり強くなる。

## コメント
- コメントを書いてはいけないなどと言うつもりは全くない。
- ここでコメントについて言及しているのは、コメントが不吉な臭いの予兆として考えることができるため。
- コメントの必要性を感じた時にはリファクタリングを行なって、コメントを書かなくとも内容がわかるようなコードを目指すこと。

# 第12章 継承の取り扱い

- 特性を継承階層に沿って上下に移動させたいことはよくある。
    - 「**メソッドの引き上げ**」、「**フィールドの引き上げ**」、「**コンストラクタ本体の引き上げ**」、「**メソッドの押し下げ**」、「**フィールドの押し下げ**」でこれを扱う。
- 継承階層にクラスを加えたり取り除いたりしたいこともある。
    - 「**スーパークラスの抽出**」、「**サブクラスの削除**」、「**クラス階層の平坦化**」で可能となる。
- サブクラスを追加することで、値によって振る舞いを変えさせるためのフィールドを置き換えることもある。
    - 「**サブクラスによるタイプコードの置き換え**」で行う。
- 継承は強力なツールだが、ふさわしくない場所で使っていたり、利用場所がふさわしくなくなったりすることがある。
    - 「**委譲によるサブクラスの置き換え**」、あるいは「**委譲によるスーパークラスの置き換え**」を適用して、継承を委譲に変える。

## メソッドの引き上げ
逆：メソッドの押し下げ

### 動機
- 重複するコードを取り除くことは重要である。重複は常に、一方の変更がもう一方に反映されないかもしれないというリスクを意味する。そして、重複を見つけるのは 一般に困難である。
- 「メソッドの引き上げ」を適用する最も単純なケースは、二つ以上のメソッドが同じ内容を持ち、コピー&ペーストが行われたことが暗示される場合である。
- 「メソッドの引き上げ」は、他のステップの後で行うことがよくある。
    - 異なるクラスの二つのメソッドをパラメータ化すれば同じメソッドになる場合、最短のステップは、それぞれに「パラメータによる関数の統合（第11章）」を適用してから「メソッドの引き上げ」をすることである。
- 「メソッドの引き上げ」で最も厄介な状況は、サブクラスにあってスーパークラスにない特性をメソッド本体が参照している場合である。その場合は、先にそれらの要素に対して「フィールドの引き上げ（第12章）」や「メソッドの引き上げ 」を適用する必要がある。

### 手順
- 引き上げたいメソッドが同一であるか精査する。
- メソッド本体内のすべてのメソッド呼び出しとフィールドの参照が、スーパークラスから呼び出し可能な特性を参照していることを確認する。
- メソッドのシグネチャ（メソッド名とほぼ同義）が異なる場合は、「**関数宣言の変更（第6章）**」を適用して、スーパークラスで使用したいシグネチャに変更する。
- スーパークラスに新しいメソッドを作成する。いずれかのメソッド本体をそこにコピーする。
- 静的コード解析を行う。
- 一つのサブクラスのメソッドを削除する。
- テストする。
- サブクラスのメソッドがすべてなくなるまで、削除を繰り返す。

## フィールドの引き上げ
逆：メソッドの押し下げ

### 動機
- サブクラスが別々に開発されたり、リファクタリングによって統合されたりした結果、特性が重複することはよくある。
- 特にフィールドは重複しやすい。各サブクラスで同じように使われていれば、それらはスーパークラスに引き上げることができる。
- これを行うと、二つの面で重複を減らせる。
    - 重複したデータ定義を取り除けること
    - そのフィールドを使用する振る舞いもサブクラスからスーパークラスに移動可能になること
- 多くの動的言語では、フィールドをクラス定義の一部として定義しない。代わりに、最初に割り当てられたときにフィールドが現れる。なので、フィールドを引き上げるには「コンストラクタ本体の引き上げ（第12章）」が不可欠になる。

### 手順
- 引き上げたいフィールドを使っている呼び出し元が、すべて同じやり方でフィールドを利用し ているかどうか詳しく調べる。
- フィールド名が異なる場合は、「フィールド名の変更（第9章）」を適用して同じ名前にする。
- スーパークラスに新しいフィールドを一つ作成する。
    - そのフィールドは、各サブクラスからアクセス可能にする必要がある（一般的な言語なら protectedと指定する）。
- サブクラスのフィールドを削除する。
- テストする。

## コンストラクタ本体の引き上げ

### 動機
- 動的言語で「フィールドの引き上げ（第12章）」を行う場合、「コンストラクタ本体の引き上げ」が不可欠になる。
- コンストラクタは何をどの順序で行うかについて特別なルールがあるため、通常の「メソッドの引き上げ」とは少し違ったアプローチが必要になる。
- このリファクタリングが混乱し始めたときは、「ファクトリ関数によるコンストラクタの置き換え（第11章）」を試みる。

### 手順
- スーパークラスのコンストラクタが存在しなければ、コンストラクタを定義する。サブクラスのコンストラクタがそれを呼び出すようにする。
-  「ステートメントのスライド」を適用して、super の呼び出しの直後に共通のステー トメントを移動する。
- 共通なコードを各サブクラスから削除して、スーパークラスに入れる。共通なコードが参照するパラメータをスーパークラスのコンストラクタに追加する。
- テストする。
- コンストラクタの先頭に移動できない共通コードがある場合は、「関数の抽出（第6章）」を行ってから「メソッドの引き上げ（第12章）」を適用する。

## メソッドの押し下げ
逆：メソッドの引き上げ

### 動機
- あるメソッドが一つのサブクラス（または少数のサブクラス）だけに関わる処理を行っている場合、そのメソッドをスーパークラスから取り除き、（一つ以上の）サブクラスに持っていくことで、クラス構造が明快になる。
- このリファクタリングは、呼び出し先が特定のサブクラスであることを呼び出し側がわかっている場合にのみ適用できる。そうでない場合は、スーパークラスに擬似的な振る舞いを配置して「ポリモーフィズムによる条件記述の置き換え」を 適用するのがよい。

### 手順
- 対象となるメソッドを、それを必要とするすべてのサブクラスにコピーする。
- スーパークラスからそのメソッドを削除する。
- テストする。
- そのメソッドを必要としないすべてのサブクラスからそのメソッドを削除する。
- テストする。

## フィールドの押し下げ
逆：フィールドの引き上げ

### 動機
- あるフィールドが一つのサブクラス（または少数のサブクラス）だけで使用されている場合、そのフィールドをスーパークラスからサブクラスに移動する。

### 手順
- 対象となるフィールドを、それを必要とするすべてのサブクラスに定義する。
- スーパークラスからそのフィールドを削除する。
- テストする。
- そのフィールドを必要としないすべてのサブクラスからそのフィールドを削除する。
- テストする。

## サブクラスによるタイプコードの置き換え
包含：State/Strategyによるタイプコードの置き換え
包含：サブクラスの抽出
逆：サブクラスの削除

### 動機
- ソフトウェアシステムでは、類似しているが少し違うものを表現したいといったことがよくある。これに対処する第一の手段は、なんらかのタイプコード用フィールドを使うことである。
- タイプコードの利用にサブクラスを加えるメリットが二つある。
    - 一つは、条件付きロジックを処理するためにポリモーフィズムを使えること。
    - 二つ目は、タイプコードが特定の値の時だけ有効なフィールドやメソッドがある場合に有効であること。
- このリファクタリングを適用する場合は、着目しているクラスを直接サブクラス化するか、タイプコードそのものをサブクラス化するかを検討する必要がある。

### 手順
- タイプコード用フィールドを自己カプセル化する。
- タイプコード値を一つ選択し、そのタイプコード用のサブクラスを作成する。そのタイプコードの getter を上書きして、リテラルのタイプコード値を返すようにする。
- タイプコードのパラメータから新しいサブクラスに変換するための選択ロジックを作成する。
- テストする。
- タイプコードの値ごとにサブクラスの作成と選択ロジックの追加を繰り返す。変更のたびにテストする。
- タイプコード用フィールドを削除する。
- テストする。
- タイプコードのアクセサを使用するすべてのメソッドに対して「メソッドの押し下げ」および「ポリモーフィズムによる条件記述の置き換え（第10章）」を適用する。すべてを置き換えたら、タイプコードのアクセサを削除できる。

## サブクラスの削除
逆：サブクラスによるタイプコードの置き換え

### 動機
- プログラムが進化するにつれて、サブクラスがサポートするバリエーションが別の場所に移動されたり、まるごと削除されたりして、サブクラスの存在価値がなくなってしまうことがある。
- そのような場合、サブクラスを取り除いてスーパークラスのフィールドに置き換えるのが最善である。

### 手順
- 当該サブクラスのコンストラクタに「ファクトリ関数によるコンストラクタの置き換え（第11章）」を適用する。
- サブクラスのタイプを判定しているコードがあるなら、そのタイプ判定に「関数の抽出（第6章）」を適用し、さらに「関数の移動（第8章）」を適用してその処理をスーパークラスに移動する。変更が終わるたびにテストする。
- サブクラスのタイプを表すフィールドを作成する。
- サブクラスを参照しているメソッドを、この新しいタイプフィールドを使用するように変更する。
- サブクラスを削除する。
- テストする。

このリファクタリングは、よくひとまとまりのサブクラスに対して行われる。その場合は、サブクラスをカプセル化する手順（ファクトリ関数を追加し、タイプ判定を移動する）を実行してから、それらを一つひとつスーパークラスに格納する。

## スーパークラスの抽出

```
class Department {
  get totalAnnualCost() {...}
  get name() {...}
  get headCount() {...}
}

class Employee {
  get annualCost() {...}
  get name() {...}
  get id() {...}
}
```
↓
```
class Party {
  get name() {...}
  get annualCost() {...}
}

class Department extends Party {
  get annualCost() {...}
  get headCount() {...}
}

class Employee extends Party {
  get annualCost() {...}
  get id() {...}
}
```

### 動機
- 二つのクラスが同じようなことをしていたら、継承の基本的なメカニズムを使って、その類似点をスーパークラスにまとめるのが良い。
- 継承は分類構造に基づいて前もって設計すべきという意見もあるが、プログラムの進化の過程で共通の要素をまとめておきたくなることから発見されていく継承もよくある。
- 「スーパークラスの抽出」の代わりになるものとしては「クラスの抽出（第7章）」があるが、通常は「スーパークラスの抽出」がより簡単なアプローチである。

# 第11章 APIのリファクタリング


- すぐれた API は、データを更新する関数とデータを参照するだけの関数を明確に分離する。
    - 上記が混在しているのを見つけたら、「問い合わせと更新の分離」を適用して分離する。
    - 値の違いだけで変化する関数のバリエーションは、「パラメータによる関数の統合」を適用して統合する。
    - 振る舞いを切り替えるだけのパラメータは「フラグパラメータの削除」を適用して削除する。
- 関数間でデータ構造が受け渡されるとき、必要以上に細切れにされることがよくある。その場合、「オブジェクトそのものの受け渡し」を適用して、まとめて渡すようにする。
    - 何をパラメータとして渡すか、何を関数内で取得するかの判断の過程では、「問い合わせによるパラメータの置き換え」と「パラメータによる問い合わせの置き換え」の間を行ったり来たりすることになる。
- オブジェクトは可能な限り不変にすべきなので、「setterの削除」を使えるところがあればすぐに適用する。
- 新たに生成されたオブジェクトを呼び出し元が必要とするときは、コンストラクタよりも柔軟な仕組みがほしくなることがよくある。その場合は「ファクトリ関数によるコンストラクタの置き換え」を適用する。
- 大量のデータを受け渡すような、かなり複雑な関数を分解するときは、「コマンドによる関数の置き換え」を適用し、関数をオブジェクトに変換する。
- 後に、その関数が簡単になってコマンドオブジェクトにしておく必要がなくなったときは、「関数によるコマンドの置き換え」を適用して関数に戻す。

## 問い合わせと更新の分離

### 動機
- 観察可能な副作用がない関数は、悩む必要を大幅に減らす。
    - 観察可能な副作用があると、問い合わせごとに異なる結果が返ることがある。
- 値を返すにもかかわらず副作用を持つメソッドがあったら、更新を行う箇所から問い合わせを分離すべき。

### 手順
- 関数をコピーして、問い合わせ用の名前をつける。
    - コピーした関数を問い合わせ関数とし、元の関数は更新関数に変更することになる。
- 新しい問い合わせ関数から副作用をすべて除去する。
- 静的検査を実行する。
- 元の関数の呼び出しを調べる。戻り値を使っている場合は、その呼び出しを問い合わせ関 数の呼び出しに置き換え、元の関数の呼び出しをその後ろに挿入する。変更のたびにテ ストする。
- 元の関数から戻り値を削除する。
- テストする。

## パラメータによる関数の統合

### 動機
- リテラル値が異なるだけの非常によく似たロジックを持つ二つの関数があるなら、異なる値を 渡すためのパラメータを持った一つの関数に統合することで、重複を排除できる。
- これにより、異なる値を必要とする別の場所でも適用できるようになるため、関数の有用性が高まる。

### 手順
- 類似の関数のうち、一つを選ぶ。
- 「関数宣言の変更」を適用して、リテラル値をすべてパラメータに変換する。
- その関数を呼び出しているすべてのところで、対応するリテラル値を渡す。
- テストする。
- 新しいパラメータを使用するように関数の本体を変更し、そのたびにテストする。
- 類似の関数それぞれについて、元の関数呼び出しをパラメータ付きの関数呼び出しに置き 換えて、そのたびにテストする。
    - このパラメータ付きの関数が、類似の関数に適合しないときは、うまく適合するように調整し てから次の類似の関数に取りかかる。

## フラグパラメータの削除

### 動機
- フラグ引数は、呼び出し元が呼び出し先に対してどのロジックを実行してほしいかを指示する ためのパラメータとして使われる。
- フラグ引数は好ましくない。どの関数呼び出しが使えるか、それをどう呼び出せばよい かを理解するプロセスが煩雑になるからである。
- フラグ引数を削除し、明示的な関数に変更することで、コードは明快になる。
- 関数に複数のフラグ変数がある場合、すべての組み合わせに対応した明示的な関数を作成する煩雑さを避けられる点で存在価値があると言えるが、それは一つの関数が多くのことをやりすぎている兆候でもある。より単純な関数を作ってロジックを実現する方法を探すべきである。

### 手順
- パラメータの値に対応して明示的な関数を作成する。
    - メインとなる関数に明確な切り替え用の条件文がある場合は、「条件記述の分解（第10章）」を適用して明示的な関数に分解する。それ以外の場合は、ラッピング関数を作成する。
- パラメータにリテラル値を指定している呼び出し元を、対応する明示的な関数呼び出しに置き換える。

ラッピング関数の例
```
function rushDeliveryDate(anOrder) {return deliveryDate(anOrder, true);}
function regularDeliveryDate(anOrder) {return deliveryDate(anOrder, false);}
```

## 問い合わせによるパラメータの置き換え
逆：パラメータによる問い合わせの置き換え（第11章）

### 動機
- 関数のパラメータリストは、関数の可変部分を縮約して、関数の振る舞いの主なバリエーショ ンを表すようにすべきである。
- このリファクタリングを避ける場合の主な理由は、パラメータを取り除くことで関数本体に望ましくない依存関係が増えてしまうから、というものである。（パラメータを取り除く場合、基本的にはその値を決める責務を関数側に移すことになるため。）
- パラメータリスト内の他のパラメータに問い合わせることで、取り除こうとしているパラメー タの値が求まるなら、このリファクタリングを行っても安全である。
- 対象とする関数の参照透過性（同じパラメータ値で呼び出したときに関数が同じ振る舞いをするかどうか）を失うような変更は避けるべき。（例えば、パラメータをグローバル変数の問い合わせに置き換えるようなこと）

### 手順
- 必要に応じて、パラメータを算出している箇所に「関数の抽出（第6章）」を適用する。
- 関数本体でのパラメータへの参照を、その値を取得する式への参照に置き換える。変更のたびにテストする。
- 「関数宣言の変更（第6章）」を適用してそのパラメータを取り除く。

## パラメータによる問い合わせの置き換え
逆：問い合わせによるパラメータの置き換え（第11章）

### 動機
- ときに関数のスコープ内で好ましくない参照をしている場合がある。（例えば、グローバル変数への参照など）
- これを解決するには、内部の参照をパラメータに置き換えて、その参照を特定する責務を関数の呼び出し側に移す必要がある。
- 関数がスコープ内で参照透過ではない要素にアクセスしている場合、その関数も参照透過性を失う。これは、その要素をパラメータに移動することで解決できる。
- このリファクタリングにはデメリットもある。
    - 問い合わせをパラメータに移動すると、その値を提供する方法は呼び出し側で考える必要がある。
    - これは呼び出し側に面倒を押しつけることになり、呼び出し側が楽になるようにインタフェースを設計していることに反する。
    - 結局はプログラムの責務の配置問題に行き着くが、その判断はとても難しくかつ移ろいやすいものである。だからこそ、このリファクタリングに慣れ親しんでおく必要がある。

### 手順
- 問い合わせを行なっている箇所に「変数の抽出（第6章）」を適用して、関数本体の残りの部分から分離する。
- 問い合わせ以外の関数本体のコードに「関数の抽出（第6章）」を適用する。
- 「変数のインライン化（第6章）」を適用して、先ほど作成した変数を取り除く。
- 元の関数に「関数のインライン化（第6章）」を適用する。
- 新しい関数の名前を元の関数の名前に変更する。

## setterの削除

### 動機
- オブジェクトを生成した後でフィールドを変更したくないなら、setterは用意しない（加えて、フィールドを変更不可にする）。そうすることで、フィールドはコンストラクタでのみ設定され、変更させないという意図が明確になって、フィールドが変更される可能性をたいていは排除できる。

### 手順
- 設定したい値がコンストラクタに渡されない場合は「関数宣言の変更（第6章）」を適用して パラメータを追加する。コンストラクタ内に setter の呼び出しを追加する。
    - 複数の setter を取り除きたい場合には、それらすべての値をまとめてコンストラクタに追加 する。これにより、後のステップが簡単になる。
- コンストラクタ以外での setter の呼び出しを一つひとつ取り除いて、新しいコンストラクタ を呼び出すようにする。取り除くたびにテストする。
    - setterの呼び出しを、新しいオブジェクトをコンストラクタで生成する方法に置き換えられないことがある（共有したオブジェクトを更新しているため）。その場合は、このリファクタリングをあきらめる。
- setter に対して「関数のインライン化（第6章）﻿」をする。可能であれば、フィールドを変更 不可にする。
- テストする。

## ファクトリ関数によるコンストラクタの置き換え

### 動機
- コンストラクタには、通常の関数にはない厄介な制限がある。
- ファクトリ関数にはそうした制約がない。

### 手順
- ファクトリ関数を作成する。その関数の本体でコンストラクタを呼び出す。
- 既存のコンストラクタの呼び出しを、一つひとつファクトリ関数の呼び出しに置き換える。
- 変更のたびにテストする。
- コンストラクタの可視性をできるだけ制限する。

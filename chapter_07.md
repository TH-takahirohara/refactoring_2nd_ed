# 第7章　カプセル化

- モジュールとして分割すべきかを決める基準としておそらく最も重要なことは、システムの他の部分から隠蔽すべき秘密を持っているかということである。データ構造は最も典型的な秘密。データ構造は「レコードのカプセル化（p.168）」や「コレクションのカプセル化（p.176）」によるカプセル化で隠蔽できる。
- クラスは情報隠蔽のために設計された。
- クラスやモジュールはカプセル化の最大の形式だが、関数もまたその実装をカプセル化している。

## レコードのカプセル化
```
organization = {name: "Acme Gooseberries", country: "GB"};
```
↓
```
class Organiztion {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }
  get name()    {return this._name;}
  set name(arg) {this._name = arg;}
  get country()    {return this._country;}
  set country(arg) {this._country = arg;}
}
```
### 動機
- レコード構造は、プログラミング言語の一般的な機能である。
- 単純なレコード構造の欠点は、レコードに格納されている値と計算した値の明確な区別を強要されることである。
- 上記を避けるために、変更可能なデータについてはレコード化するよりもオブジェクト化した方が良い。オブジェクトであれば、保持されているものを隠蔽し、格納される値と計算した値の両方を同じように取得できる。
- レコードの構造には、正規にフィールド名を宣言したものと、任意の名前を使えるものの2種類がある。
- 後者はハッシュ、マップ、ハッシュマップ、辞書、連想配列などと呼ばれ、クラスライブラリで提供される。
- 欠点はどのようなフィールドを保持するかが明示されないこと。
- 暗黙のレコードを明示的なレコードにすることもできるが、どうせならクラスにすれば良い。

 ### 手順
1. レコードを保持する変数に「変数のカプセル化（p.138）」を施す。
2. 変数の中身を、レコードをラップする簡単なクラスに置き換える。レコードをそのまま返すアクセサをそのクラスに定義する。変数をカプセル化する関数を変更して、アクセサを使うようにする。
3. テストする。
4. レコードそのものではなくオブジェクトを返す関数を用意する。
5. レコードの使用箇所ごとに、レコードを返す関数の呼び出しを、オブジェクトを返す関数の呼び出しに置き換える。フィールドデータの取得にはオブジェクトのアクセサを使うようにする。必要ならばそのためのアクセサを作る。変更のたびにテストする。
6. 生データへのアクセサと、検索しやすくしておいたレコードそのままを返す関数をクラスから取り除く。
7. テストする。
8. レコードのフィールド自体が構造体である場合、「レコードのカプセル化」と「コレクションのカプセル化（p.176）」を再帰的に施すことを検討する。

## コレクションのカプセル化
```
class Person {
  get courses() {return this._courses;}
  set courses(aList) {this._courses = aList;}
```
↓
```
class Person {
  get courses() {return this._courses.slice();}
  addCourse(aCourse)    {...}
  removeCourse(aCourse) {...}
```

### 動機
- コレクションの扱いについてよくある誤りは、コレクションの変数へのアクセスはカプセル化されていても、getterでコレクションそのものを返してしまうと、コレクションを保持するクラスを介さずに、その中身を変更できてしまうことである。
- これを避けるため、コレクションの内容を変更するメソッドをクラスに用意する。
- また、コレクションに対してアクセスする最も一般的な方法は、コレクションの取得メソッドを用意し、それにコレクションのコピーを返させると言うもの。

### 手順
1. コレクションの参照がまだカプセル化されていないなら「変数のカプセル化」を施す。
2. 要素を追加・削除するための関数をコレクションに追加する。
3. 静的チェックを実行する。
4. 全てのコレクションの参照を探す。コレクションの変更メソッドを読んでいる場合は、新たな追加・削除のメソッドを使うように全て書き換える。変更のたびにテストする。
5. コレクションのgetterを変更して、保護されたビュー（読み取り専用プロキシまたはコピー）を返すようにする。
6. テストする。

## オブジェクトによるプリミティブの置き換え
```
orders.filter(o => "high" === o.priority
                || "rush" === o.priority);
```
↓
```
orders.filter(o => o.priority.higherThan(new Priority("normal")))
```

### 動機
- 開発の初期段階では、情報を見たままのデータ項目で表現しがち。
- しかし、開発が進むにつれ、単純でなくなっていき、ロジックの重複が増加する。
- 単純な表示以上のことをする必要があると分かったら、新たなクラスにする。そうすることで、必要に応じて固有の振る舞いを追加できる。

### 手順
```
class Order...
  constructor(data) {
    this.priority = data.priority
    // 初期化が続く

client...
  highPriorityCount = orders.filter(o => "high" === o.priority
                                      || "rush" === o.priority)
                            .length;
```
- 「変数のカプセル化（p.138）」ができていないならば、施す。
```
class Order...
  get priority()        {return this._priority;}
  set priority(aString) {this._priority = aString;}
```
- データ値のための単純な値クラスを作る。既存の値をコンストラクタで受け取り、値を返すgetterを用意する。
```
class Priority {
  constructor(value) {this._value = value;}
  toString() {return this._valiue;}
}
```
- 静的チェックを実行する。
- 値クラスのインスタンスを作るようにsetterを変更し、インスタンスのフィールドに値を格納するようにする。必要に応じてその型を変える。
```
class Order...
  get priority()        {return this._priority.toString();}
  set priority(aString) {this._priority = new Priority(aString);}
```
- getterを変更し、値クラスのgetterの呼び出し結果を返すようにする。
```
class Order...
  get priorityString() {...}
  
client...
  highPriorityCount = orders.filter(o => "high" === o.priorityString
                                      || "rush" === o.priorityString)
                            .length;
```
- テストする。
- 処理内容がより分かるように、元のアクセサに「関数名の変更（p.130）」の適用を検討する。
- 新たなオブジェクトの役割が値オブジェクトなのか参照オブジェクトなのかを明確にすることを検討する。検討の結果、値オブジェクトにするなら「参照から値への変更（p.260）」を施す。参照オブジェクトにするなら「値から参照への変更（p.264）」を施す。

## 問い合わせによる一時変数の置き換え
```
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
  return basePrice * 0.95;
else
  return basePrice * 0.98;
```
↓
```
get basePrice() {this._quantity * this._itemPrice;}
...
if (this.basePrice > 1000)
  return this.basePrice * 0.95;
else
  return this.basePrice * 0.98;
```

### 動機
- 変数はそれ自体便利だが、さらに関数にすると有意義な場合がある。
- 関数の分解時に変数を関数に置き換えると、抽出される関数に逐一パラメータとして変数を渡す必要がなくなるため、関数の抽出が容易になる。
- 変数の代わりに関数を使うことで、計算ロジックの抽出を避けられる。
- このリファクタリングはクラスの中で使うのが最も効果的である。抽出しようとしているメソッド間で共通の文脈を与えてくれるからである。
- 「問い合わせによる一時変数の置き換え」に適した一時変数はほんの一部で、あらかじめ計算された結果を後から参照するためだけの変数に限られる。

### 手順
- 一時変数の値は、それが使われる前に確定していることを確認する。また、それを計算するコードはいつ使っても常に同じ結果になることを確認する。
- 一時変数が読み取り専用でないときは、可能であれば読み取り専用にする。
- テストする。
- 一時変数への代入を関数として抽出する。
- テストする。
- 「変数のインライン化（p.129）」を施して、一時変数を取り除く。

## クラスの抽出
逆：クラスのインライン化（p.193）
```
class Person {
  get officeAreaCode() {return this._officeAreaCode;}
  get officeNumber()   {return this._officeNumber;}
```
↓
```
class Person {
  get officeAreaCode() {return this._telephoneNumber.areaCode;}
  get officeNumber()   {return this._telephoneNumber.number;}
}
class TelephoneNumber {
  get areaCode() {return this._areaCode;}
  get number()   {return this._number;}
}
```

### 動機
- クラスに責務を追加していくと、やがて手に負えないほど複雑になる。
- 大きすぎて容易に理解できないクラスは、切り出す必要がある。
- その際の目安となるのは、データとメソッドの一部（部分集合）をまとめて別のクラスにできそうかどうかである。
- 他にも、データの一部（部分集合）が同時に変更されたり、互いに強く依存したりしている関係にあれば、それも目安になる。

### 手順
- クラスの責務をどのように切り出すかを決める。
- 切り出した責務を記述するための新たな子クラスを作る。
- 元の親クラスのインスタンスを生成する時に、新たな子クラスのインスタンスも作り、親インスタンスから子インスタンスへのリンクを加える。
- 移動したい各フィールドに「フィールドの移動（p.215）」を施す。移動の度にテストする。
- メソッドを子クラスに移動するために「関数の移動（p.206）」を施す。低レベルのメソッド（呼ぶ側ではなく呼ばれる側）から着手する。移動の度にテストする。
- 両クラスのインタフェースを見直す。不要なメソッドを取り除き、新たな状況にふさわしい名前に変更する。
- 新たな子クラスのインスタンスを公開するかどうか決める。公開するなら、「参照から値への変更（p.260）」を新たなクラスに施すことを検討する。
    - 公開すると、親クラスのメソッド内の子インスタンスへの参照を、アクセサに置き換えられる。

## クラスのインライン化
逆：クラスの抽出（p.189）
```
class Person {
  get officeAreaCode() {return this._telephoneNumber.areaCode;}
  get officeNumber()   {return this._telephoneNumber.number;}
}
class TelephoneNumber {
  get areaCode() {return this._areaCode;}
  get number()   {return this._number;}
}
```
↓
```
class Person {
  get officeAreaCode() {return this._officeAreaCode;}
  get officeNumber()   {return this._officeNumber;}
```

### 動機
- クラスがその役割を終えて、存在価値がなくなったら「クラスのインライン化」を施す。
- クラスから責務を移動するリファクタリングの結果、責務がほとんの残っていないクラスができたら、それを別のクラスに畳み込む。畳み込み先として、このクラスを最もよく使うクラスを選ぶ。
- 他にも、二つのクラスをリファクタリングして特性の配置を換えたい時にも行う。その場合、「クラスのインライン化」で一つのクラスにまとめてから「クラスの抽出（p.189）」で改めて分離した方が簡単。

### 手順
- インライン先のクラスに、元のクラスの全てのpublic関数に対応する関数を作る。これらは元のクラスに委譲するだけの関数である。
- 元のクラスのメソッドへの参照を全て変更し、インライン先のクラスの委譲メソッドを使うようにする。変更のたびにテストする。
- 全ての関数とデータを、元のクラスからインライン先に移す。一つ移すごとにテストする。これを元のクラスが空になるまで繰り返す。
- 元のクラスを削除し、ささやかな弔いをする。

## 委譲の隠蔽
逆：仲介人の除去（p.199）
```
manager = aPerson.department.manager;
```
↓
```
manager = aPerson.manager;

class Person {
  get manager() {return this.department.manager;}
```

### 動機
- カプセル化によって、各モジュールはシステムの他の部分について知るべきことが少なくなる。何かが変更されても、影響を受けるモジュールの数は少なくなるため、変更がしやすくなる。
- サーバオブジェクトがクライアントコードと委譲先のオブジェクトの中間にあるような構成を考える。
- 委譲先のオブジェクトがインタフェースを変更すると、委譲先のオブジェクトを保持するサーバオブジェクトのクライアントにも変更が波及する。
- この依存関係を断ち切るために、委譲先のオブジェクトを隠すための単純な委譲用メソッドをサーバオブジェクトに置く。
- 委譲先のオブジェクト変更の影響は、サーバオブジェクトに限定され、末端のクライアントには波及しなくなる。

![スクリーンショット 2020-03-21 1.27.34.png (23.7 kB)](https://img.esa.io/uploads/production/attachments/13309/2020/03/21/66250/18577233-a54d-4465-9e98-18be2549d6f3.png)

### 手順
- 委譲先のオブジェクトの各メソッドに対応する単純な委譲用メソッドをサーバオブジェクトに作る。
- クライアントを修正し、サーバオブジェクトの委譲メソッドを呼ぶようにする。変更のたびにテストする。
- クライアントで委譲先のオブジェクトへのアクセスが必要な箇所がなくなったなら、委譲先のオブジェクトへのアクセサをサーバオブジェクトから取り除く。
- テストする。

## 仲介人の除去
逆：委譲の隠蔽（p.196）
```
manager = aPerson.manager;

class Person {
  get manager() {return this.department.manager;}
```
↓
```
manager = aPerson.department.manager;
```

### 動機
- 「委譲の隠蔽（p.196）」の動機では、委譲先のオブジェクトをカプセル化することの有効性について述べたが、この対価として、クライアントが委譲先のオブジェクトの新たな特性を使おうとするたびに、単純な委譲メソッドをサーバオブジェクトに追加しなければならない。
- そうなってくると、もはやサーバオブジェクトはただの「仲介人（p.84）」に過ぎず、委譲先のオブジェクトを直接呼ばせた方が良い。（「デメテルの法則」は参考程度にしておいた方が良い。）
- 隠蔽をどの程度施すのが適切なのかを見極めるのは難しい。システムの変化次第で調整すべし。

### 手順
- 委譲先のオブジェクトを取得するgetterを作る。
- 委譲メソッドを使用するクライアントごとに、委譲メソッドへの呼び出しをgetterから始まるメソッドチェーンで置き換える。変更のたびにテストする。

## アルゴリズムの置き換え
```
function foundPerson(people) {
  for (let i = 0; i < people.length; i++) {
    if (people[i] === "Don") {
      return "Don";
    }
    if (people[i] === "John") {
      return "John";
    }
    if (people[i] === "Kent") {
      return "Kent";
    }
    return "";
```
↓
```
function foundPerson(people) {
  const candidates = ["Don", "John", "Kent"];
  return people.find(p => candidates.includes(p)) || '';
}
```

### 動機
- アルゴリズムは、よりわかりやすい方法が見つかったら、複雑な方法をそれで置き換えるべきである。
- アルゴリズムに手を加えて動作を少し変えたい時、まず必要な変更がしやすい形に置き換えてから行う方が簡単な場合もある。
- このステップを実行する前に、メソッドをなるべく分解しておく。

### 手順
- 完結した機能を果たすように置き換え前のコードを整える。
- この機能だけを使ったテストを用意して、その振る舞いを把握する。
- 代わりのアルゴリズムを用意する。
- 静的チェックを実行する。
- テストを実行して古いアルゴリズムと新たなアルゴリズムの出力結果を比較する。それらが同じなら終了する。違えば、古いアルゴリズムを比較対象としてテストとデバッグを行う。
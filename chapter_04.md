# 第4章 テストの構築
- 堅牢なテストスイートが、適切なリファクタリングには必要。
- 良いテストを書くとプログラマとしての生産性は高まる。

## 自己テストコードの意義
- プログラマは、実際にコードを書く時間は短く、多いのはデバッグにかかる時間である。
- 全てのテストを完全に自動化し、テスト自身に結果をチェックさせること。
- テストを揃えておくと、それらを頻繁に実行することで、バグの発見にかかる時間は削減される。
- テストはプログラミングを始める前に手をつけるのが良い。新たな機能を追加する時、テストから書き始める。
- テストを書くことで、機能を追加するためにすべきことを自問することになる上、実装よりもインタフェースに集中することになる。コーディングが完了する時点も、テストがうまく行った時となる。
- Kent Beckは、この習慣をテスト駆動開発（TDD）と言う形でまとめた。この方法は、まず（失敗する）テストをを書き、テストが通るようにプログラムを書き、その後でコードができるだけ明快になるようにリファクタリングすると言うものであり、心からお勧めでできるものである。
- リファクタリングにはテストは必須だが、本書はテストの本ではないので、詳細には立ち入らない。
- 既存コードのリファクタリング時には、着手前にコードを自己テスト化する必要がある。

## テストのためのサンプルコード

- サンプルコードの概要を述べる。
- 生産計画の画面に、地域ごとに製品の需要と価格が表示される。
- 地域ごとに生産者がおり、設定された価格（コスト）で一定量の生産が可能。
- 生産量の全てが売れた場合の総収入も示される。
- 下部には、生産量の不足分と利益を示す。
- ユーザは、需要、価格、個々の生産者の生産量やコストを変更し、不足分や利益を確認できる。

- ビジネスロジックの部分、つまり利益と不足分の計算を行う箇所に焦点を当てる。
- ビジネスロジックのコードは二つのクラスからなる。一つは個々の生産者、もう一つは地域を表す。

```
class Province...
  constructor(doc) {
    this._name = doc.name;
    this._producers = [];
    this._totalProduction = 0;
    this._demand = doc.demand;
    this._price = doc.price;
    doc.producers.forEach(d => this.addProducer(new Producer(this, d)));
  }
  addProducer(arg) {
    this._producers.push(arg);
    this._totalProduction += arg.productoin;
  }
```

- 生産量が需要よりも多い場合、需要と（生産者ごとの）生産量を比較し、小さい方の値をcontributionに代入。まず残りの需要（remainingDemand）から引き、コストとしてcontribution * costの値を追加していく。

## 最初のテスト
- テストフレームワークとして、JavaScriptのMochaを使った例を示す。
不足分を計算するshortfallメソッドの単純なテストの例

```
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData());
    assert.equal(asia.shortfall, 5);
  });
});
```

- Mochaでは、テストコードをブロックの単位に分割する。

- 失敗すべき時にテストが正しく失敗するかを常に確認する。

- よくできたテストフレームワークでは多くのテストを簡単に実行でき、失敗箇所もすぐに示してくれる。
- 頻繁にテストを実行するべき。作業中のコードについては少なくとも2~3分に1回、そして少なくとも1日に1回は全てのテストを実行する。

- Mochaでは、様々なアサーション用ライブラリを使うことができる。
- 本書ではChaiでの例を示す。Chaiでは検査用のコードをassert形式で書くことができる。
コード例

- テスト実行の方式は環境によって様々。
- グラフィカルなテストランナーもあり、素晴らしいが、不可欠ではない。
- 大切なのは、全てのテストが成功しているかを、すぐに確認できること。

## テストの追加
- 著者のテスト追加のスタイルは、クラスがなすべきことを全て調べた後、それらについて一つずつ、失敗しそうな条件でテストするというもの。
- テストはリスク主導であるべき。単純すぎるメソッドは必ずしもテストしなくても良い。これは重要なことである。一番怪しいと思う部分を集中的にテストすることが最も効果的。
- 実行されない完全なテストよりも、実行される不完全なテストの方がましである。

- コードの重複を避けるために共通のフィクスチャを作るのは危険である。オブジェクトの内容を書き換えてしまうようなことがあれば、フィクスチャに依存したテスト群が失敗することがあり、その場合デバッグが困難になるため。
- 各テストが走る前に、都度新たなフィクスチャを生成するような関数がテストフレームワークに用意されていることがあるので、それを利用すると良い。

## フィクスチャの変更
- フィクスチャを「設定」してから、テストの中でフィクスチャに関わるコードを「実行」し、期待した結果になっているかどうかを「検証」する。

## 境界値の検査
- ここまでのテストは、通常の場合を対象としていた。
- しかし、条件の境界となる箇所で、通常と異なる時に何が起きるかをテストすることも有効。
- この例のProducerのように、何らかの集合を扱う場合は、空の時にどうなるか確認すると良い。
- 境界条件のコードを書くことで、その場合にどのように振る舞うべきか考える機会が得られるので良い。
- 失敗する可能性のある境界条件を考えて、そこを集中的にテストする。
- テスト失敗とエラーは別物。
- テストのやめ時はいつか。リスクがどこにあるかに注目し、作業の進度に合わせてテストを追加していく。
- テストでほとんどのバグが見つからないと言って、テストを書くのをやめてはならない。テストではほとんどのバグが捕捉される。

## これより先には
- 本書はリファクタリングについてのものなので、テストについてはこれで終わる。
- 本章で示したテストはいわゆる単体テストであり、自己テストコードの核となる。
- 自己テストされるシステムにおいて、ほとんどのテストは単体テストだからである。
- バグに対処するために、まずバグを明白に再現できるテストを書くというのは、身につけるべき大切な習慣である。
- バグレポートを受け取ったら、まずそのバグの存在を明確に示す単体テストを書くところから始めること。
- どれだけテストをすれば十分なのか、適切な指標はない。指標としてテストカバレージを勧める人もいるが、カバレージによる分析が有効なのは、コード中のまだテストされていない箇所を突き止める場合のみであり、テストスイート自体の品質を保証するものではない。
- 十分なテストスイートが揃っているかどうかは、主観で決めるのが最も良い。自己テストコードの目的は、誰かがコード中に欠陥を埋め込んだら、テストは失敗するという確信を持てることにある。テストが過剰になることは滅多にない。